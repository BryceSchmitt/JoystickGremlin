\documentclass[a4, 10pt]{article}


% +-----------------------------------------------------------------------------
% | Packages
% +-----------------------------------------------------------------------------

% AMS math packages
\usepackage{amsmath,amssymb}
\allowdisplaybreaks

% Proper unit placement
\usepackage{siunitx}

% Figure related packages
\usepackage{graphicx}
\usepackage[font={footnotesize}]{subcaption}
\usepackage{placeins}

% Better tables
\usepackage{booktabs}

% Reference styling
\usepackage[noconfig]{refstyle}
\input{refconfig.cfg}

% Source code formatting
\usepackage{minted}
\usemintedstyle{friendly}

% Tikz setup
\usepackage{tikz}
\usetikzlibrary{external}
%\tikzexternalize[prefix=tikz/]
% Define good colors
\definecolor{col1}{rgb}{1.00, 0.14, 0.14}
\definecolor{col2}{rgb}{0.13, 0.17, 0.53}
\definecolor{col3}{rgb}{0.99, 0.68, 0.38}
\definecolor{col4}{rgb}{0.67, 0.87, 0.64}

\definecolor{linkcol}{rgb}{0.039, 0.336, 0.527}

% Fixme notes
\usepackage{fixme}
\fxsetup{%
    status=draft,
    theme=color
}

% Comment boxes
\usepackage[tikz]{bclogo}

% Hyperref configuration
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=linkcol,
    urlcolor=linkcol,
    % PDF attributes
    pdfauthor={Lionel Ott},
    pdftitle={Joystick Gremlin Manual},
}

% Citation format
\usepackage[square,numbers,comma,sort]{natbib}

% Redefine the \vec command to use bold font instead of an arrow
\DeclareMathOperator*{\argmax}{\arg\!\max}

% Text replacement commands
\newcommand{\JG}{Joystick Gremlin}


\begin{document}

\include{title_page}

\tableofcontents
\newpage


% +-----------------------------------------------------------------------------
% | Introduction
% +-----------------------------------------------------------------------------
\section{Introduction}
\label{sec:introduction}


\subsection{Overview}

\JG{} is a program that allows the configuration of joystick like
peripherals. It is similar to programs such as CH Products' CH Control
Manager and Thrusmaster's T.A.R.G.E.T. However, it is manufacturer
agnostic and thus works with devices from any manufacturer and uses
Python as its scripting language. The major features of Joystick Gremlin
are:
\begin{itemize}
    \item Merging of multiple devices into a single device
    \item Axis response curve and dead zone configuration
    \item Arbitrary number of modes with customisable mode switching and
        inheritance
    \item Keyboard macros
    \item Python scripting support
\end{itemize}

\JG{} provides a graphical user interface which allows commonly
performed tasks, such as input remapping, axis response curve setups,
and macro recording to be performed easily. Functionality that is not
accessible via the UI can be implemented through custom modules,
explained in \secref{custom_modules} in detail.


\subsection{Installation}
\JG{} has one major dependency, vJoy which provides virtual joysticks
which \JG{} feeds with data. Download links to the programs needed are
listed below:
\begin{itemize}
    \item \href{https://github.com/WhiteMagic/JoystickGremlin}{\JG{}}
    \item \href{http://vjoystick.sourceforge.net/site/}{vJoy} (direct
        download link
        \href{http://sourceforge.net/projects/vjoystick/files/Beta%202.x/2.0.5-120515/vJoy_205_050515.exe/download}{2.0.5
        2015-05-12})
    \item
        \href{http://www.microsoft.com/en-us/download/details.aspx?id=5555}{VC
        Redistributable 2010}
\end{itemize}

vJoy creates virtual joysticks which show up as a device in Windows and
\JG{} uses these to forward inputs to them. The VC2010 package is
required by Python but is likely to already installed.

\subsubsection{vJoy Configuration}

In order to properly use \JG{} vJoy has to be configured first. This is
done via the \emph{Configure vJoy} program. This program allows setting
the properties of all existing vJoy devices. Typically a single vJoy
device is enough. In order to use 8-way POV hats with \JG{} the hats
have the be configured as continuous in vJoy. \figref{vjoy-config} shows
what a properly configured vJoy device looks like. Once everything is
set as desired clicking \emph{Ok} configures the vJoy device and closes
the program.

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.5\linewidth]{images/vjoy_configuration}
    \caption{vJoy Configuration program showing the correct setting for
        the POV hats as well as having all 8 axis and 64 buttons
        configured.}
    \label{fig:vjoy-config}
\end{figure}


\subsection{Concepts}
\label{sec:concepts}

The following section introduces the terminology used by \JG{}.


\subsubsection{Profile}
A profile is a folder which contains a XML configuration file together
with any custom modules used. The profile contains the settings made via
the user interface for each of the connected peripherals.

\subsubsection{Input}
An input is an axis, button, hat, or keyboard key on a physical device.
Each input can have multiple actions assigned to it and these actions
can change between the different modes.

\subsubsection{Action}
An action is something \JG{} executes when an input is used. Examples
include running a macro, sending button presses to vJoy, or changing to a
different mode. Each action has a condition attached to it which
dictates when it is executed. For buttons this is the state, i.e.\
pressed or released.

\subsubsection{Mode}
A mode is a collection of actions associated with different inputs.
Each mode can inherit from one other mode, his parent. If a mode and its
parent both define actions for the same input only the actions of the
mode and not its parent are used. Similarly, if the mode defines no
actions for an input but the parent does the parent's actions are used.
This allows having a common set of base commands that more specialised
modes add to or change.



% +-----------------------------------------------------------------------------
% | Using the User Interface
% +-----------------------------------------------------------------------------
\section{Using the User Interface}
\label{sec:gui}

In the following the various components of the user interface are
introduced and their usage described. The UI should be sufficient for
most common use cases, however, if functionality is missing user created
modules can provide these.


\subsection{Overview}

The following is a short overview of the different components that make
up the main user interface, shown in \figref{main-ui}.

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.95\linewidth]{images/main_window}
    \caption{The main screen of the user interface.}
    \label{fig:main-ui}
\end{figure}

\begin{enumerate}
    \item Overview of all the inputs available for a given device. The
        small icons on the far right of each input indicate the type of
        actions associated with the input. \emph{A} is a control action,
        \emph{C} is a response curve, \emph{M} is a macro, and \emph{R} is
        a remapping.
    \item The right hand portion of the UI shows the list of actions
        associated with the currently selected input. This panel allows
        the customisation of existing actions and the addition of new
        ones.
    \item The mode section allows changing the mode currently being
        configured.
    \item The status bar shows whether or not the program is currently
        running a profile. If the program is running the currently
        active mode is shown as well if code execution is paused.
    \item Tool bar with the main actions, from left to right
        \begin{itemize}
            \item Open an existing profile, discarding the current one
                and any unsaved changes to it.
            \item Activate \JG{}, when active the button is pressed and
                a green icon is shown. This also changes the status bar
                display. Pressing the button while \JG{} is running
                will disabled it again.
            \item Generate code, this generates a configuration based on
                the current settings. This is also done automatically
                when \JG{} is activated.
        \end{itemize}
    \item Each tab represents an individual device that is currently
        connected to the computer.
\end{enumerate}


\subsection{Actions}

As described in \secref{concepts}, each input, such as axis, button,
hat, or keyboard key, can have multiple actions associated with them.
However, not all inputs have access to the same types of actions as they
are not applicable to them. In the following all available actions are
described.

Each action has an activation condition associated with it which can be
used for fine grained control over them. Additionally, each input can
also be configured to be always executed by checking the \emph{Always
Execute} box, see 2. in \figref{main-ui}. Enabling this option results
in actions associated with that input to be performed even if execution
of callbacks is paused. This is mainly useful for resuming when
execution has been paused.

\vspace{1em}
\begin{bclogo}[
    couleur=yellow!40,
    couleurBord=orange!80,
    couleurBarre=orange!80,
    arrondi=0.1,
    logo=\bcinfo
]{Note}
    Activation conditions are currently only implemented for joystick
    buttons and keyboard keys.
\end{bclogo}


\subsubsection{Remapping}

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.75\linewidth]{images/action_remap}
    \caption{Remap widget allowing the mapping of a physical joystick
        input to an equivalent input on a vJoy device.}
    \label{fig:action_remap}
\end{figure}

The remapping action, shown in \figref{action_remap}, enables the user
to propagate inputs from a physical joystick input to an equivalent vJoy
input, i.e.\ axis to axis, button to button, and hat to hat. This allows
the merging of multiple physical devices into a single device.

\vspace{1em}
\begin{bclogo}[
    couleur=yellow!40,
    couleurBord=orange!80,
    couleurBarre=orange!80,
    arrondi=0.1,
    logo=\bcinfo
]{Note}
    In most cases remap actions should always trigger, i.e.\ on button press and
    release, as otherwise the forwarding to vJoy is incomplete.
\end{bclogo}


\subsubsection{Response Curve}

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.75\linewidth]{images/action_response_curve_bezier}
    \caption{The response curve dialogue allows the customisation of the
        joystick response as well as the dead zone.}
    \label{fig:action_response_curve}
\end{figure}

The response curve dialogue, shown in \figref{action_response_curve},
allows the customisation of the response produced by the joystick using
the curve editor. The shape of the curve is controlled using a set of
control points.

A new control point is added by a double left click in an empty area of
the curve editor. Removing an existing control point is achieved by
selecting the desired point and pressing the ``Delete'' key on the keyboard.
A single left click on a control point will mark the point as active. An
active point can be dragged in the window to modify its position.
Alternatively, the text fields below the curve editor allow for precise
numerical values to be entered.

Finally the dead zones for the axis can be defined using the sliders and
input fields at the bottom of the dialogue. The fields and sliders
control the full deflection dead zone (1st and 4th field from the left) as well as
the centre deflection dead zones (2nd and 3rd field).

Currently there are two types of response curve types available which
are selected from the drop down menu at the top of the widget:
\begin{description}
    \item[Cubic Spline] A simple spline with only control points dictating
        locations the curve has to pass through. No control over the
        shape is provided.
    \item[Cubic B\'{e}zier Spline] A more complex spline with control
        points and ``handles'' that can modify the shape of the overall
        curve. Importantly this curve allows the control of how the
        curve approaches the end points of the curve.
\end{description}

\begin{bclogo}[
    couleur=yellow!40,
    couleurBord=orange!80,
    couleurBarre=orange!80,
    arrondi=0.1,
    logo=\bcinfo
]{Note}
    A response curve mapping action always needs to be paired with a
    remap action, as otherwise the transformation will not have any
    effect.
\end{bclogo}

\vspace{1em}

\begin{bclogo}[
    couleur=yellow!40,
    couleurBord=orange!80,
    couleurBarre=orange!80,
    arrondi=0.1,
    logo=\bcinfo
]{Note}
    In order for response curves to work properly the game has to be
    configured to use a linear 1:1 curve, as otherwise the two curve
    settings will interfere with each other producing undesirable
    results.
\end{bclogo}


\subsubsection{Macro}

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.75\linewidth]{images/action_macro}
    \caption{Macro recording widget containing a simple sequence of
    keys.}
    \label{fig:action_macro}
\end{figure}

The macro dialogue, see \figref{action_macro}, allows the creation of
keyboard macros. The macro can contain any combination of key presses
and releases, as well as pauses between individual actions.

Adding new keystrokes to a macro is done by pressing the \emph{Record}
button, after which all keystrokes will be recorded sequentially. To
stop the recording simply press the \emph{Record} button again. A pause
can be added by pressing the \emph{Add Pause} button, which will insert
a pause after the currently selected entry. The length of the pause can
be modified by double clicking the entry. Selecting an entry allows it
to be moved up and down using the \emph{Up} and \emph{Down} buttons.

\vspace{1em}
\begin{bclogo}[
    couleur=yellow!40,
    couleurBord=orange!80,
    couleurBarre=orange!80,
    arrondi=0.1,
    logo=\bcinfo
]{Note}
    Each macro is executed independently, which means that multiple long
    running macros can have their key presses interfere with each other.
\end{bclogo}


\subsubsection{Pause, Resume \& Toggle}

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.95\linewidth]{images/action_pause_resume}

    \caption{Pause and resume action dialogues.}
    \label{fig:action_pause_resume}
\end{figure}

The pause, resume, and toggle actions, shown in \figref{action_pause_resume},
control whether or not \JG{} executes callbacks when inputs are used.
When the application is paused only inputs that were configured to
\emph{always execute} will be executed.

\vspace{1em}
\begin{bclogo}[
    couleur=yellow!40,
    couleurBord=orange!80,
    couleurBarre=orange!80,
    arrondi=0.1,
    logo=\bcinfo
]{Note}
    In order for the \emph{resume} and \emph{toggle} actions to be
    useful they have to be defined as \emph{always execute}, as
    otherwise it will be impossible to resume from the paused state.
\end{bclogo}


\subsubsection{Change Mode}

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.75\linewidth]{images/action_switch_mode}
    \caption{Change mode dialogue configured to switch to the
        \emph{hornet} mode.}
    \label{fig:action_change_mode}
\end{figure}

This action will change the currently active mode of \JG{} to the
specified one. The dialogue, shown in \figref{action_change_mode}, has
a simple drop down list which contains all the available modes.


\subsubsection{Switch to Previous Mode}

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.75\linewidth]{images/action_switch_previous_mode}
    \caption{Dialogue of the action that switches to the previously
    active mode.}
    \label{fig:action_previous_mode}
\end{figure}

When the input with which this action, \figref{action_previous_mode}, is
activated the active mode of \JG{} will change to the previously active
one.


\subsubsection{Cycle Modes}

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.75\linewidth]{images/action_cycle_modes}
    \caption{Mode cycling action dialogue which switches between the
        \emph{global}, \emph{hornet}, and \emph{retaliator} modes.}
    \label{fig:action_cycle_modes}
\end{figure}

This action, shown in \figref{action_cycle_modes}, allows the
configuration of a list of modes that are cycled through consecutively
with each activation. In case that the currently active mode is not part
of the list the first mode in the list will be activated.

New modes can be added by selecting the desired mode in the drop down
list and pressing the \emph{Add} button. The currently selected mode can
be deleted by pressing the \emph{Delete} button and moved up or down
with the \emph{Up} and \emph{Down} button respectively.

\FloatBarrier

\subsubsection{Text to Speech}

This action allows arbitrary text to be spoken by \JG{}. The system
knows how to replace some values with current information. The currently
known replacements are:

\begin{table}[h]
    \centering

    \begin{tabular}{ll}
        \toprule
        Expression & Replacement \\
        \midrule
        \verb+${current_mode}+ & The name of the currently active mode \\
        \bottomrule
    \end{tabular}

    \caption{List of replacements known to the text-to-speech system.}
\end{table}

\vspace{1em}
\begin{bclogo}[
    couleur=yellow!40,
    couleurBord=orange!80,
    couleurBarre=orange!80,
    arrondi=0.1,
    logo=\bcinfo
]{Note}
    The text segments are spoken in the order they are requested and as
    such queueing multiple long segments can lead to significant delays
    between them being triggered and played back.
\end{bclogo}

\FloatBarrier


\subsection{Tools}

In the following section the various tools provided by \JG{} are
described. They can be accessed via the \emph{Tools} menu.

\subsubsection{Mode Manager}

\begin{figure}[bt]
    \centering

    \includegraphics[height=3cm]{images/mode_manager}
    \quad
    \includegraphics[height=3cm]{images/module_manager}

    \caption{(Left) The mode manager allows the creation and deletion of
    modes, as well as defining their relationship.  (Right) The user
    module manager allows defining external modules to load}

    \label{fig:mode_module_screens}
\end{figure}

The mode manager, accessed via \emph{Tools $\rightarrow$ Manage Modes}
and shown in \figref{mode_module_screens} (left), allows users to create
new modes, delete existing ones and define which mode inherits
configurations from others. Pressing ``Add Mode'' adds a new mode, while
pressing the button to the right of each mode with the \textbf{X} on it
deletes it. Using the drop down menu each mode can be configured to
inherit from one other mode by selecting its name or not inheriting from
any mode by selecting the ``None'' entry.


\subsubsection{User Module Managemer}

While the UI exposes commonly performed customisations there is
functionality that is not present. However, by using custom modules,
described in \secref{custom_modules}, the limitations of the UI can
easily be overcome. The module configuration dialogue,
\figref{mode_module_screens} (right), can be opened via \emph{Tools
$\rightarrow$ Manage Custom Modules}. The modules listed there will be
loaded in conjunction with the UI based configuration, allowing the use
of the UI for common tasks and implementing specialised functionality in
a custom module. Modules are added via the \emph{Add} button and
likewise removed by selecting the desired module and pressing the
\emph{Delete} button.


\subsubsection{Input Repeater}

By enabling the \emph{Input Repeater} option via \emph{Tools
$\rightarrow$ Input Repeater}, \JG{} will repeat the last remapped input
after a short wait period. This allows button presses and axes movements
to be mapped in-game when the game detects the physical device's inputs
instead of the virtual ones.


\subsubsection{Device Information}

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.75\linewidth]{images/device_information}
    \caption{Overview of the inputs and identification of the various
        joystick devices present in the system.}
    \label{fig:device_information}
\end{figure}

Information about connected devices can be accessed via \emph{Tools
$\rightarrow$ Device Information}. This window, shown in
\figref{device_information}, provides an overview of the devices known
to \JG{}, listing the name as well as some basic information about each
device. The \emph{System ID} represents the order in which the devices
are seen by the operating system, while the \emph{Hardware ID} is an
identifier that is unique to each device.

\vspace{1em}
\begin{bclogo}[
    couleur=yellow!40,
    couleurBord=orange!80,
    couleurBarre=orange!80,
    arrondi=0.1,
    logo=\bcinfo
]{Note}
    The currently used hardware id is not device, but product specific.
    As such it can not distinguish between two identical joysticks. To
    distinguish those the system id is used. When there are no duplicate
    devices present the system id is ignored.
\end{bclogo}


\subsubsection{Calibration}

\begin{figure}[bt]
    \centering

    \includegraphics[width=0.6\linewidth]{images/calibration}
    \caption{The calibration tool allows the calibration of all
    connected devices independent of Windows.}
    \label{fig:calibration}
\end{figure}

The axes calibration screen, \figref{calibration} accessed via
\emph{Tools $\rightarrow$ Calibration}, allows the calibration of
connected devices independent of Windows. The window shows the current,
minimum, centre, and maximum value for each analogue axis of the
selected device. To calibrate the axes simply move them through their
full range and press the \emph{Centered} button when all axes are
centred. Once done press \emph{Save} to save the calibration of the
currently selected device to the configuration file.


\subsubsection{Cheatsheet Generation}

To help remember complex setups \JG{} has the ability to create PDF and
HTML cheatsheets of the current profile. The output lists for each mode
the actions of the available devices together with the user provided
description.


% +-----------------------------------------------------------------------------
% | Writing Custom Modules
% +-----------------------------------------------------------------------------
\section{Writing Custom Modules}
\label{sec:custom_modules}

While common configuration tasks can be performed directly via the UI,
more advanced and specialised configurations require writing custom
modules. Each module is a simple Python script which defines the
functions (callbacks) triggered in reaction to inputs being used. Since
the functions are written in Python there is no limit as to what can be
expressed. The following section assumes some basic familiarity with
Python. In \secref{cm_principles} a general overview of the layout of a
custom module is given which is followed by an quick overview of the API
in \secref{cm_api}. Finally, \secref{cm_examples} provides a few
practical examples.


\subsection{Principle \& Layout of Custom Modules}
\label{sec:cm_principles}

Joystick Gremlin uses callbacks, i.e.\ functions that are executed in
reaction to user inputs such as key presses or axis motions. These
callbacks have access to some convenience functions which allow
accessing and controlling commonly used parts of the system, such as
setting the value of vJoy devices or retrieving keyboard and joystick
states. Combining these readily available functions with custom code
allows the implementation of varied functionality.

The general structure of a callback is as follows:
\begin{minted}{text}
    @decorator_function(<input name>)
    def callback_function(event, <optional parameter list>):
        <callback implementation>
\end{minted}

The \verb+event+ parameter contains information about the event that
triggered the execution of the function. Each event is of type
\verb+gremlin.event_handler.Event+ and contains the following data:

\begin{itemize}
    \item \verb+event_type+ The type of the event, which matches that
        of the decorator used to decorate the function.
    \item \verb+identifier+ The identifier of the input, which matches
        that of the decorator used to decorate the function.
    \item \verb+hardware_id+ The hardware id of the device, which
        matches that of the decorator used to decorate the function.
    \item \verb+windows_id+ The windows id of the device, which matches
        that of the decorator used to decorate the function.
    \item \verb+is_pressed+ Boolean flag indicating if a button or key
        is pressed. This field's value is only valid for joystick
        buttons and keyboard keys.
    \item \verb+value+ Value of an axis or hat. In case of an axis the
        value is in the range $\left[-1, 1\right]$ and in the case of a
        hat a tuple (x direction, y direction) is used. This field's
        value is only valid for is only for joystick axes and hats.
    \item \verb+raw_value+ The raw axis value. This field's value is
        only valid if the \verb+event_type+ represents an axis.
\end{itemize}

From this list the only values that are typically of interest are the
\verb+is_pressed+ and \verb+value+ entries.


\subsection{API}
\label{sec:cm_api}

The following describes the API of the optional variables exposed via
the decorator callback framework.


\subsubsection{vJoy}

Any decorated function that has a parameter named \verb+vjoy+ in its
parameter list will have access to all vJoy devices.  Accessing a
specific \verb+VJoy+ instance is done by indexing the \verb+vjoy+
object. This object then allows setting the state of inputs by indexing
the member variables \verb+axis+, \verb+button+, and \verb+hat+.  All
indices start with $1$. The following demonstrates typical usage:

\begin{minted}{python}
    # Access the first vJoy device and press the third button
    vjoy[1].button[3].is_pressed = True
    # Access the second vJoy device and move the Y axis to -0.25
    vjoy[2].axis[AxisName.Y].value = -0.25
    # Access the first vJoy device and move the first hat to
    # the top right position
    vjoy[1].hat[1].hat[1].direction = 45
\end{minted}


\subsubsection{Joystick State}

Any decorated function that has a parameter named \verb+joy+ in its
parameter list will have access to all joystick devices via that
variable.

\vspace{1em}
\noindent\textbf{Accessing a specific joystick}

\noindent In order to access a specific joystick its system id needs to
be known. Using the device's system id as index the joystick can be
accessed by:
\begin{minted}{python}
    joystick_device = joy[system_id]
\end{minted}


\noindent\textbf{Reading axis value}

\noindent To read the current value of a joystick axis both the index of
the axis as well as the system id of the joystick, starting with $1$,
are needed, with these the axis value is obtained as:
\begin{minted}{python}
    axis_value = joy[system_id].axis(axis_index)
\end{minted}


\noindent\textbf{Reading button state}

\noindent To read the current state of a button both the joystick's
system id as well as index of the button, starting at $1$, are needed.
The following then reads the button state:
\begin{minted}{python}
    is_pressed = joy[system_id].button(button_id)
\end{minted}


\noindent\textbf{Reading hat position}

\noindent To read the current position of a hat both the joystick's
system id and hat index, starting at $1$, are needed. The position of
the hat is reported as a $(x, y)$ tuple $x, y \in \{-1, 0, 1\}$. A $x$
value of $1$ is right and $-1$ left while a value of $1$ for $y$ means
up and $-1$ down. The value is read as follows:
\begin{minted}{python}
    position = joy[system_id].hat(hat_id)
\end{minted}


\subsubsection{Keyboard State}

Any decorated function that has a parameter named \verb+keyboard+ in its
parameter list will have access to the state of all keyboard keys.

\vspace{1em}
\noindent\textbf{Reading key state}

\noindent To read the key state the string representation of the key or
the \texttt{gremlin.macro.\allowbreak Key} instance corresponding to the
key is needed. Both can be found in the \texttt{gremlin.macro} module.
Reading the state is then done as follows:
\begin{minted}{python}
    is_pressed = keyboard.is_pressed(key)
\end{minted}


\subsection{Decorator Based Callback Generation}

Callbacks reacting to user inputs are created by decorating functions
using specific decorators. There are two types of decorators, one for
joysticks and one for the keyboard. Joystick decorators are created for
specific devices using the\\
\verb+gremlin.input_devices.JoystickDecorator+ class as follows:
\begin{minted}{python}
    joystick_decorator = gremlin.input_devices.JoystickDecorator(
        <device name>,
        <device id>,
        <mode>
    )
\end{minted}

The value of \verb+<device id>+ depends on whether or not multiple
devices of the same type are being used. In the case of multiple
identical devices \verb+device_id+ consists of the tuple of the
\verb+hardware_id+ and \verb+windows_id+, otherwise, only the
\verb+hardware_id+ is used. An object created in this way has three
decorators customised for the given joystick and mode, which can be used
as follows:
\begin{minted}{python}
    @joystick_decorator.axis(1)
    def axis_callback(event):
        pass

    @joystick_decorator.button(4)
    def button_callback(event):
        pass

    @joytick_decorator.hat(2)
    def hat_callback(event):
        pass
\end{minted}

The keyboard decorator can be used directly as follows:
\begin{minted}{python}
    @gremlin.input_devices.keyboard(<key name>, <mode>)
    def keyboard_callback(event):
        pass
\end{minted}

Where \verb+<key name>+ can be either a string representation of the
key's name as or an instance of \verb+gremlin.marco.Keys.Key+ which are
both defined in\\\verb+gremlin.macro+ module.

The \verb+event+ parameter of the decorated function is always required
and contains the state of the input used in the decoration, as described
in \secref{cm_api}.


\subsection{Examples}
\label{sec:cm_examples}

In the following a few examples of custom modules are shown. They
provide an illustration of some of the things that can be achieved
thanks to the combination of \JG{} provided functions and custom Python
code.


\subsubsection{Keyboard Controlled Throttle}

This script allows the user to control an analogue throttle in $1/3$rd
increments using the $1$, $2$, $3$, and $4$ number keys.

\inputminted[xleftmargin=2em]{python}{examples/keyboard_throttle.py}


\subsubsection{Joystick Response Curve}

This script configures a response curve which provides more control
around the centre position and uses it for the $X$ and $Y$ axis of the
joystick.

\inputminted[xleftmargin=2em]{python}{examples/response_curve.py}


\subsubsection{Mode Switching}

This script presents a few different ways of using mode switching
functionalities. The first callback switches to the \emph{Radio} mode
while the button is being held down and switches back to the previous
mode once the button is released. The next callback cycles through the
\emph{Global}, \emph{Radio}, and \emph{Landing} modes with each button
press. The last callback switches directly to the \emph{Global} mode
when the button is pressed.

\inputminted[xleftmargin=2em]{python}{examples/mode_switching.py}


\subsubsection{Precision Mode}

This script switches to a lower sensitivity curve when any of the
weapon groups are being fired and switches back to the default profile
once no weapon is being fired any more. This is similar to the ``sniper
mode'' that some gaming mice have, which drops the DPI setting at the
press of a button. In this instance pressing the trigger automatically
enables and disables this by switching the used response curve to one
which halves the maximum response provided by the joystick at maximum
deflection.

\inputminted[xleftmargin=2em]{python}{examples/precision_mode.py}



% +-----------------------------------------------------------------------------
% | Technical Design
% +-----------------------------------------------------------------------------
\section{Technical Design}
\label{sec:technical_design}

This section contains information related to implementation details of
\JG{}. This is mainly intended for those that want to get a deeper
understanding of the internals or extend \JG{} in some way.


\subsection{Qt Signal \& Slots for Input Event Communication}

The inputs generated by the user are captured by the
\verb+EventListener+ class in the \verb+gremlin.event_handler+ module,
where they are turned into an \verb+Event+ object which is propagated
using Qt's signal / slot
mechanism\footnote{\url{http://doc.qt.io/qt-4.8/signalsandslots.html}}.
Joystick events are retrieved using SDL2 while keyboard events are
capture by hooking directly into the Windows event queue.


\subsection{Threaded Macro System}

Each macro consists of a sequence of actions which are executed one
after the other. Each macro is run in a separate thread in order to
prevent \JG{} to become unresponsive. This allows multiple macros to run
at the same time and over long periods of time. However, a side effect
of this is that if multiple long running macros are active at the same
time they can interfere with each other.


\subsection{Action Plugin System for UI Widgets}

Every action exposed in the UI consists of two classes derived from
\texttt{Abstract\allowbreak Action} and \texttt{AbstractActionWidget}. A
class derived from \texttt{AbstractAction} is responsible for the data
of the action including parsing from XML, generating XML, and generating
Python code.  The \texttt{AbstractActionWidget} on the other hand is
responsible for the presentation of the data, updating the state of the
data to the \texttt{AbstractAction}, and initialising the UI based on
\texttt{AbstractAction} data.

Each \verb+AbstractAction+ class has to provide the following information
in the form of class variables:
\begin{itemize}
    \item \verb+icon+, the path to the image to use as indicator icon in
        the input item selection list
    \item \verb+name+, the name to use when displaying this action
    \item \verb+widget+, the widget class used by the UI to represent
        this action
    \item \verb+input_types+, the list of \verb+InputType+ this action
        is applicable to
\end{itemize}
In addition to these variables each implementation has to define the
following methods:
\begin{itemize}
    \item \verb+_parse_xml(self, node)+, which parses the provided XML
        node into internal storage
    \item \verb+_generate_xml(self)+, which returns a XML node
        representing the object's content
    \item \verb+_generate_code(self)+, which returns a dictionary
        containing the Python code for this action
\end{itemize}

The widget which is used to display and configure the action has to be
derived from the \verb+AbstractActionWidget+ class. Each derived class
needs to provide implementations of the following methods:
\begin{itemize}
    \item \verb+_setup_ui(self)+, which creates all the UI elements and
        other structures necessary for the proper working of the widget
    \item \verb+to_profile(self)+, which updates the contents of the
        derived \verb+AbstractItem+ associated with this widget
    \item \verb+initialize_from_profile(self, action_data)+, which
        initialises the data displayed by the widget with the data of
        the provided profile action
\end{itemize}

Any newly created action needs to have its corresponding
\verb+AbstractItem+ class registered in the \verb+action_lookup+ table
in the \verb+gremlin.profile+ module.


\subsection{XML Storage}

Each profile is stored in a single XML file. The contents of the XML
file are used to populate the UI as well as generate Python code
representing the profile. The file is parsed by the \verb+Profile+ class
in the \verb+gremlin.profile+ module.



\section{Changelog}

\subsection{Release 3}

\textbf{New features}
\begin{itemize}
    \item Added text-to-speech support
    \item Modes now can form arbitrary, user defined inheritance trees
    \item Generation of HTML and PDF cheatsheets
    \item Ability to assign actions to individual hat directions
    \item Ability to add a description to each input
    \item Improved cubic Bezier spline interface
    \item Select input currently being used on the physical device
    \item Modes can now have arbitrary names
    \item Action to toggle pause mode on and off
    \item Getting started tab with a quick guide added
    \item Simple text-to-speech support
\end{itemize}

\textbf{Fixes}
\begin{itemize}
    \item Timeout issues making vJoy fail fixed
    \item More error handling and fixing of edge cases
\end{itemize}


\subsection{Release 2}

\textbf{New features}
\begin{itemize}
    \item Input repeating for binding actions in games
    \item Storing of last used profile to auto load on next start
    \item Calibration of joystick axes
    \item Cubic Bezier splines added for response curve configuration
    \item Properly support multiple identical devices
\end{itemize}

\noindent \textbf{Fixes}
\begin{itemize}
    \item XML profile parsing error handling improved
    \item Accidental overwriting of an existing profile after creating a
        new one
    \item Some error handling improvements
\end{itemize}



% +-----------------------------------------------------------------------------
% | Bibliography
% +-----------------------------------------------------------------------------
%\bibliographystyle{plainnat}
%\bibliography{bibliography}

\end{document}
