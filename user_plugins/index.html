---
area: manual
chapter: user_plugins
layout: default
---

<h1><a name="4">4. User Plugins</a></h1>

<p class="text-justify">
    While common configuration tasks can be performed directly via the
    UI, more advanced and specialised configurations may either only be
    possible or much simpler by using a user plugin. Each plugin is a
    simple Python script which defines the variables a user can
    configure via the UI and the functions (callbacks) triggered in
    reaction to (configured) inputs being
    used. Since the functions are written in Python there is no limit as
    to what can be expressed. The following section assumes some basic
    familiarity with Python.
</p>

<p class="text-justify">
    We start with a general overview of the
    layout of a user plugin in <a href="#4_1">Section 4.1</a> which is
    followed by an quick overview of the API in <a href="#4_2">Section
    4.2</a> followed by the description of the decorator based callback
    system in <a href="#4_3">Section 4.3</a> with periodic function
    callbacks described in <a href="#4_4">Section 4.4</a>. Some words on how
    to debug user plugins is provided in <a href="#4_5">Section 4.5</a>.
    Finally, <a href="#4_6">Section 4.6</a> provides a few practical
    examples.
</p>


<h2><a name="4_1">4.1 Principles &amp; Layout of User Plugin</a></h2>

<p class="text-justify">
    Joystick Gremlin uses callbacks, i.e. functions that are executed in
    reaction to user inputs such as key presses or axis motion. These
    callbacks have access to some convenience functions which allow
    accessing and controlling commonly used parts of the system, such as
    setting the value of vJoy devices or retrieving keyboard and
    joystick states. Combining these readily available functions with
    custom code allows the implementation of varied functionality.
</p>

<p class="text-justify">
    In order to make user plugins reusable and convenient to use a set
    of classes exist which allow setting them via the UI, thus allowing
    a user to customize the plugins directly from the UI. These variable
    classes allow configuration of commonly used types such as modes,
    inputs, as well as numerical values.
</p>

<p class="text-justify">
    The general structure of a callback is as follows:
{% highlight python3 %}@decorator_function(<input name>)
def callback_function(event, <optional parameter list>):
    <callback implementation>{% endhighlight %}
</p>

<p class="text-justify">
    The <code>event</code> parameter contains information about the
    event that triggered the execution of the function. Each event is of
    type <code>gremlin.event_handler.Event</code> and contains the
    following data:
</p>

<div class="card border-dark mb-3">
    <div class="card-header">
        <h5 class="class-title">Event</h5>
    </div>
    <div class="card-body pb-0">
        <dl class="row">
            <dt class="col-md-4"><code>event_type</code></dt>
            <dd class="col-md-8">The type of the event this represents.</dd>

            <dt class="col-md-4"><code>identifier</code></dt>
            <dd class="col-md-8">The identifier of the event source.</dd>

            <dt class="col-md-4"><code>hardware_id</code></dt>
            <dd class="col-md-8">Hardware ID assigned to the deivce that created the event.</dd>

            <dt class="col-md-4"><code>windows_id</code></dt>
            <dd class="col-md-8">Index assigned by Windows to the device that created the event.</dd>

            <dt class="col-md-4"><code>is_pressed</code></dt>
            <dd class="col-md-8">If the event represents a button or key the value is True for pressed and False for released state.</dd>

            <dt class="col-md-4"><code>value</code></dt>
            <dd class="col-md-8">Value of an axis or hat. In case of an axis the
                value is in the range {% raw %}\(\left[-1, 1\right]\){% endraw %}
                and in the case of a hat a tuple (x direction, y direction) is
                used. This field's value is only valid for joystick axes and
                hats.</dd>

            <dt class="col-md-4"><code>raw_value</code></dt>
            <dd class="col-md-8">The raw axis value, this field is only valid for joystick
                axes.</dd>
            </dl>
    </div>
</div>

<p class="text-justify">
    From this list the only values that are typically of interest are
    the <code>is_pressed</code> and <code>value</code> entries depending
    on the input type.
</p>


<h2><a name="4_2">4.2 Device Access API</a></h2>

<p class="text-justify">
    The following describes the API of the optional variables exposed
    via the decorator plugin framework. The plugins provide access to
    commonly used information by simply adding a properly named
    parameter to the callback function.
</p>
<p class="text-justify">
    These parameters must be listed after the event parameter in the
    case of user input callbacks.
</p>



<h3>vJoy</h3>

<p class="text-justify">
    Any decorated function that has a parameter named <code>vjoy</code>
    in its parameter list will have access to all vJoy devices.
    Accessing a specific <code>VJoy</code> instance is done by indexing
    the <code>vjoy</code> object. This object then allows setting the
    state of inputs by indexing the member variables <code>axis</code>,
    <code>button</code>, and <code>hat</code>. All indices start with 1.
    The following demonstrates typical usage:
</p>

{% highlight python3 %}# Access the first vJoy device and press the third button
vjoy[1].button(3).is_pressed = True

# Access the second vJoy device and move the Y axis to -0.25
vjoy[2].axis(AxisName.Y).value = -0.25
# or equivalently
vjoy[2].axis(2).value = -0.25

# Access the first vJoy device and move the first hat to
# the top right position
vjoy[1].hat(1).direction = (1, 1){% endhighlight %}


<h3>Joystick State</h3>

<p class="text-justify">
    Any decorated function that has a parameter named <code>joy</code>
    in its parameter list will have access to all joystick devices via
    that variable.
</p>


<p class="text-justify">
    <b>Accessing a specific joystick</b></br>
    In order to access a specific joystick its system id needs to be
    known. Using the device's system id as index the joystick can be
    accessed by:
    {% highlight python3 %}joystick_device = joy[system_id]{% endhighlight %}
    If no duplicate devices are present another option to access a specific
    joystick is to use its name as follows:
    {% highlight python3 %}joystick_device = joy["T.16000M"]{% endhighlight %}
</p>


<p class="text-justify">
    <b>Reading axis value</b></br>
    To read the current value of a joystick axis both the index of the
    axis as well as the system id of the joystick, starting with 1, are
    needed, with these the axis value is obtained as:
    {% highlight python3 %}axis_value = joy[system_id].axis(axis_index).value{% endhighlight %}
</p>

<p class="text-justify">
    <b>Reading button state</b></br>
    To read the current state of a button both the joystick's system id
    as well as index of the button, starting at 1, are needed. The
    following then reads the button state:
    {% highlight python3 %}state = joy[system_id].button(button_id).is_pressed{% endhighlight %}
</p>


<p class="text-justify">
    <b>Reading hat position</b></br>
    To read the current position of a hat both the joystick's system id
    and hat index, starting at 1, are needed. The position of the hat is
    reported as a {% raw %}\((x, y)\){% endraw %} tuple {% raw %}\(x, y
    \in \left\{-1, 0, 1\right\}\){% endraw %}. A \(x\) value of 1 is right
    and -1 left while a value of 1 for \(y\) means up and -1 down. A
    value of \(0\) represents a centred position. The value is read as follows:
    {% highlight python3 %}position = joy[system_id].hat(hat_id).direction{% endhighlight %}
</p>


<h3>Keyboard State</h3>

<p class="text-justify">
    Any decorated function that has a parameter named
    <code>keyboard</code> in its parameter list will have access to the
    state of all keyboard keys.
</p>

<p class="text-justify">
    <b>Reading key state</b></br>
    To read the key state the string representation of the key or the
    <code>gremlin.macro.Key</code> instance corresponding to the key is
    needed. Both can be found in the <code>gremlin.macro</code> module.
    Reading the state is then done as follows:
    {% highlight python3 %}is_pressed = keyboard.is_pressed(key){% endhighlight %}
</p>


<h2><a name="4_3">4.3 User Input Callback Generation</a></h2>

<p class="text-justify">
    Callbacks reacting to user inputs are created by decorating functions using
    specific decorators. Here are two useful links if you're not familiar with
    decorators, <a href="https://www.python.org/dev/peps/pep-0318/">official
    PEP</a> and an <a href="https://stackoverflow.com/questions/739654/how-to-make-a-chain-of-function-decorators/1594484#1594484">exhaustive
    StackOverflow answer</a> There are two types of decorators,
    one for joysticks and one for the keyboard. Joystick decorators are created
    for specific devices using the
    <code>gremlin.input_devices.JoystickDecorator</code> class as follows:
{% highlight python3 %}joystick_decorator = gremlin.input_devices.JoystickDecorator(
    <device name>,
    <device id>,
    <mode>
){% endhighlight %}
</p>

<p class="text-justify">
    The value of <code>&lt;device id&gt;</code> depends on whether or not
    multiple devices of the same type are being used. In the case of
    multiple identical devices <code>device_id</code> consists of the
    tuple of the <code>hardware_id</code> and <code>windows_id</code>,
    otherwise, only the <code>hardware_id</code> is used. An object
    created in this way has three decorators customised for the given
    joystick and mode, which can be used as follows:
{% highlight python3 %}@joystick_decorator.axis(1)
def axis_callback(event):
    pass

@joystick_decorator.button(4)
def button_callback(event):
    pass

@joytick_decorator.hat(2)
def hat_callback(event):
    pass{% endhighlight %}
</p>

<p class="text-justify">
    The keyboard decorator can be used directly as follows:
{% highlight python3 %}@gremlin.input_devices.keyboard(<key name>, <mode>)
def keyboard_callback(event):
    pass{% endhighlight %}
</p>

<p class="text-justify">
    Where <code>&lt;key name&gt;</code> can be either a string representation
    of the key's name as or an instance of <code>gremlin.marco.Key</code> which
    are both defined in the <code>gremlin.macro</code> module.
</p>

<p class="text-justify">
    The <code>event</code> parameter of the decorated function is always
    required and contains the state of the input that triggered the callback,
    the contents of the variable are described in <a href="#4_1">Section
    4.1</a>.
</p>


<h2><a name="4_4">4.4 Periodic Function Callbacks</a></h2>

<p class="text-justify">
    In some situations a function needs to be executed at regular
    intervals. This is facilitated by a decorator that ensures that the
    function is run at a specified interval while Joystick Gremlin is
    active.
</p>

<p class="text-justify">
    The decorator takes a single argument that indicates the interval, i.e. the
    duration, between executions of the function in seconds. The callback
    function can use the same plugin system as the user input callbacks to gain
    access to device information, e.g. <code>vjoy</code>, <code>joy</code>, and
    <code>keyboard</code>. A generic example of periodic function callback is
    shown below.
</p>

{% highlight python3 %}@gremlin.input_devices.periodic(<seconds>)
def periodic_function():
    pass{% endhighlight %}
</p>


<h2><a name="4_5">4.5 Debugging</a></h2>

<p class="text-justify">
    To facilitate the debugging of custom modules without setting up the
    source code of Joystick Gremlin in an IDE the logging function
    <code>gremlin.util.log()</code> can be used. This stores the
    provided text to the user log file which can be viewed directly in
    Joystick Gremlin via the <em>Tools -> Log display</em> option.
</p>

<p class="text-justify">
    For more detailed debugging Joystick Gremlin needs to be run from within an
    IDE by getting the development environment setup. While this provides the
    best debugging experience it also involves the most work, thus for simple
    tasks the logging approach may be preferable.
</p>


<h2><a name="4_6">4.6 Examples</a></h2>

<p class="text-justify">
    In the following a few examples of custom modules are shown. They
    provide an illustration of some of the things that can be achieved
    thanks to the combination of Joystick Gremlin provided functions and
    custom Python code.
</p>


<h3>Keyboard Controlled Throttle</h3>

<p class="text-justify">
    This script allows the user to control an analogue throttle in 1/3rd
    increments using the <kbd>1</kbd>, <kbd>2</kbd>, <kbd>3</kbd>, and
    <kbd>4</kbd> number keys.
</p>

{% highlight python3 %}
{% include_relative keyboard_throttle.py %}
{% endhighlight %}


<h3>Joystick Response Curve</h3>

<p class="text-justify">
    This script configures a response curve which provides more control
    around the centre position and uses it for the X and Y axis of the
    joystick.
</p>

{% highlight python3 %}
{% include_relative response_curve.py %}
{% endhighlight %}


<h3>Mode Switching</h3>

<p class="text-justify">
    This script presents a few different ways of using mode switching
    functionalities. The first callback switches to the <em>Radio</em>
    mode while the button is being held down and switches back to the
    previous mode once the button is released. The next callback cycles
    through the <em>Global</em>, <em>Radio</em>, and <em>Landing</em>
    modes with each button press. The last callback switches directly to
    the <em>Global</em> mode when the button is pressed.
</p>

{% highlight python3 %}
{% include_relative mode_switching.py %}
{% endhighlight %}


<h3>Precision Mode</h3>

<p class="text-justify">
    This script switches to a lower sensitivity curve when any of the weapon
    groups are being fired and switches back to the default profile once no
    weapon is being fired any more. This is similar to the "sniper mode"
    that some gaming mice have, which drops the DPI setting at the press of
    a button. In this instance pressing the trigger automatically enables
    and disables this by switching the used response curve to one which
    halves the maximum response provided by the joystick at maximum
    deflection.
</p>

{% highlight python3 %}
{% include_relative precision_mode.py %}
{% endhighlight %}
