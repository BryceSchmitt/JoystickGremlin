---
area: manual
chapter: technical_design
layout: default
---

<h2><a name="4">4. Technical Design</a></h2>

<p class="alert alert-warning text-justify">
    This section is currently partially out of date and requires updating with
    Release 8 information.
</p>

<p class="text-justify">
    This section contains information related to implementation details of
    Joystick Gremlin. This is mainly intended for those that want to get a
    deeper understanding of the internals or extend Joystick Gremlin in some
    way.
</p>


<h3>Component Overview</h3>

<p class="text-justify">
    The following provides an overview of the various components that
    are part of Joystick Gremlin. The components can roughly be split
    into two categories: functional and user interface.
</p>


<h3><a name="4_1">4.1 Qt Signal &amp; Slots for Input Event Communication</a></h3>

<p class="text-justify">
    The inputs generated by the user are captured by the
    <code>EventListener</code> class in the <code>gremlin.event_handler</code>
    module, where they are turned into an <code>Event</code> object which
    is propagated using <a href="http://doc.qt.io/qt-4.8/signalsandslots.html">
    Qt's signal / slot</a> mechanism. Joystick events are retrieved using
    SDL2 while keyboard events are capture by hooking directly into the
    Windows event queue.
</p>


<h3><a name="4_2">4.2 Macro System</a></h3>

<p class="text-justify">
    Each macro consists of a sequence of actions which are executed one
    after the other. Each macro is run in a separate thread in order to
    prevent Joystick Gremlin to become unresponsive.
</p>
<p class="text-justify">
    In order to be provide some control over the execution of macros
    there exists a macro manager which handles the queueing and
    dispatching of macros. This permits some macros to be run in an
    exclusive mode, i.e. only the particular macro can be active and no
    other macro can run during the life time of the exclusive macro.
</p>
<p class="text-justify">
    The various modes in which a macro can be executed, i.e. repeat,
    hold, and toggle, are implemented inside the manager which takes
    care of repeating the macro and terminating it when required.
</p>


<h3><a name="4_3">4.3 Action Plugin System for UI Widgets</a></h3>

<p class="text-justify">
    Every action exposed in the UI consists of two classes derived from
    <code>AbstractAction</code> and <code>AbstractActionWidget</code>. A class
    derived from <code>AbstractAction</code> is responsible for the data of the
    action including parsing from XML, generating XML, and generating Python
    code. The <code>AbstractActionWidget</code> on the other hand is
    responsible for the presentation of the data, updating the state of the
    data to the <code>AbstractAction</code>, and initialising the UI based on
    <code>AbstractAction</code> data.
</p>

<p class="text-justify">
    Each <code>AbstractAction</code> class has to provide the following
    information in the form of class variables:
    <dl class="dl-horizontal">
        <dt><code>icon</code></dt>
        <dd>the path to the image to use as indicator icon in the input item
            selection list</dd>
        <dt><code>name</code></dt>
        <dd>the name to use when displaying this action</dd>
        <dt><code>widget</code></dt>
        <dd>the widget class used by the UI to represent this action</dd>
        <dt><code>input_types</code></dt>
        <dd>the list of <code>UIInputType</code> types this action is
    Each macro consists of a sequence of actions which are executed one after
    the other. Each macro is run in a separate thread in order to prevent
    Joystick Gremlin to become unresponsive.
            applicable to</dd>
    </dl>
    In addition to these variables each implementation has to define the
    following methods:
    <ul>
        <li><code>_parse_xml(self, node)</code>, which parses the provided XML
            node into internal storage</li>
        <li><code>_generate_xml(self)</code>, which returns a XML node
            representing the object's content</li>
        <li><code>_generate_code(self)</code>, which returns a dictionary
            containing the Python code for this action</li>
    </ul>
</p>

<p class="text-justify">
    The widget which is used to display and configure the action has to be
    derived from the <code>AbstractActionWidget</code> class. Each derived
    class needs to provide implementations of the following methods:
    <ul class="text-justify">
        <li><code>_setup_ui(self)</code>, which creates all the UI elements and
            other structures necessary for the proper working of the
            widget</li>
        <li><code>to_profile(self)</code>, which updates the contents of the
            derived <code>AbstractItem</code> associated with this widget</li>
        <li><code>initialize_from_profile(self, action_data)</code>, which
            initialises the data displayed by the widget with the data of
            the provided profile action</li>
    </ul>
</p>

<p class="text-justify">
    Any newly created action needs to have its corresponding
    <code>AbstractItem</code> class registered in the <code>action_lookup</code> dictionary
    in the <code>gremlin.profile</code> module.
</p>


<h3><a name="4_4">4.4 Container Plugin System for UI Widgets</a></h3>


<h3><a name="4_5">4.5 XML Storage</a></h3>

<p class="text-justify">
    Each profile is stored in a single XML file. The contents of the XML file
    are used to populate the UI as well as generate Python code representing
    the profile. The file is parsed by the <code>Profile</code> class in the
    <code>gremlin.profile</code> module.
</p>
